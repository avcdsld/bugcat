<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>BUGCAT House</title>
  <style>
    html, body { 
      height: 100%; 
      margin: 0;
      background: #000000;
    }
    
    body { 
      display: grid; 
      place-items: center;
      font-family: 'Courier New', Courier, monospace;
    }
    
    .container { 
      width: min(95vw, 600px);
      max-height: 95vh;
    }
    
    svg { 
      width: 100%; 
      height: 100%; 
      display: block;
    }
    
    .hex-char {
      fill: #ffffff;
      font-size: 11px;
      font-weight: normal;
      text-anchor: middle;
      dominant-baseline: middle;
    }
    
    .face-top {
      fill: #666666;
      opacity: 0.6;
    }
    
    .face-right {
      fill: #555555;
      opacity: 0.5;
    }
    
    .face-front {
      fill: #777777;
      opacity: 0.55;
    }
    
    .edge-char {
      fill: #ffffff;
      font-size: 11px;
      font-weight: normal;
      text-anchor: middle;
      dominant-baseline: middle;
    }
    
    .entrance-char {
      fill: #ffffff;
      font-size: 11px;
      font-weight: normal;
      text-anchor: middle;
      dominant-baseline: middle;
    }
  </style>
</head>
<body>
  <div class="container">
    <div id="info" style="color: #ffffff; font-size: 2.3vw; margin-bottom: 0.5vw; text-align: center; line-height: 1.3;">
      <div style="font-size: 3vw; font-weight: bold; margin-bottom: 1.2vw; opacity: 1;">BUGCAT House #10</div>
      <div id="caretaker-info" style="margin-bottom: 0.6vw; opacity: 0.9;">
        Caretaker: zeroichiarakawa.eth
      </div>
      <div id="visit-info" style="opacity: 0.8;">
        Remembers the 8th visitor: OverflowCat Â· 2025-08-24 21:15:10Z
      </div>
    </div>
    
    <svg id="house" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 600 450">
      <g id="faces"></g>
      <g id="edges"></g>
      <g id="entrance"></g>
    </svg>
  </div>
  
  <script>
    (function() {
      const NS = 'http://www.w3.org/2000/svg';
      const GRID_STEP = 10;
      const SVG_WIDTH = 600;
      const SVG_HEIGHT = 450;
      const ISO_ANGLE = Math.PI / 6;
      const SIZE = 200;
      const CENTER = { x: 300, y: 225 };
      
      const bytecode = '0x608080604052600436101561001357600080fd5b60003560e01c90816301288f3c146101b3575080633ccfd60b1461010c5780635ac687a8146100d9578063d0e30db0146100995763e3d670d71461005657600080fd5b34610094576020366003190112610094576004356001600160a01b038116908190036100945760005260006020526020604060002054604051908152f35b600080fd5b60003660031901126100945733600052600060205260406000208054903482018092116100c35755005b634e487b7160e01b600052601160045260246000fd5b3461009457600036600319011261009457602073bb9bc244d798123fde783fcc1c72d3bb8c1894133b1515604051908152f35b346100945760003660031901126100945733600052600060205260008080806040812054335af13d156101ae573d67ffffffffffffffff81116101985760405190601f8101601f19908116603f0116820167ffffffffffffffff811183821017610198576040528152600060203d92013e5b156100945733600052600060205260006040812055600080f35b634e487b7160e01b600052604160045260246000fd5b61017e565b346100945760003660031901126100945747156101cc57005b60208152600a6020820152697265656e7472616e637960b01b60408201527f55d68e0254b44d1d00659bd7e45544dea474c1b9d01304669332e1111dcd9d3360603392a200fea264697066735822122047035d28905bc373b1e74145d49a451b78a33da3f6c85822649380d964a74e3064736f6c634300081e0033';
      const hexChars = bytecode.slice(2).toUpperCase().split('');
      
      const getHex = index => hexChars[index % hexChars.length];
      
      const project = (x, y, z) => ({
        x: CENTER.x + (x - z) * Math.cos(ISO_ANGLE),
        y: CENTER.y + (x + z) * Math.sin(ISO_ANGLE) - y
      });
      
      const createText = (x, y, char, className = 'hex-char') => {
        const el = document.createElementNS(NS, 'text');
        el.setAttribute('x', x.toFixed(1));
        el.setAttribute('y', y.toFixed(1));
        el.setAttribute('class', className);
        el.textContent = char;
        return el;
      };
      
      const inside = (x, y, corners) => {
        let result = false;
        for (let i = 0, j = corners.length - 1; i < corners.length; j = i++) {
          if ((corners[i].y > y) != (corners[j].y > y) &&
              x < (corners[j].x - corners[i].x) * (y - corners[i].y) / 
                  (corners[j].y - corners[i].y) + corners[i].x) {
            result = !result;
          }
        }
        return result;
      };
      
      const offsetPolygon = (corners, offset) => {
        const cx = corners.reduce((sum, p) => sum + p.x, 0) / corners.length;
        const cy = corners.reduce((sum, p) => sum + p.y, 0) / corners.length;
        const lines = [];
        
        for (let i = 0; i < corners.length; i++) {
          const p1 = corners[i];
          const p2 = corners[(i + 1) % corners.length];
          const dx = p2.x - p1.x;
          const dy = p2.y - p1.y;
          const len = Math.hypot(dx, dy);
          
          let nx = -dy / len;
          let ny = dx / len;
          
          const midX = (p1.x + p2.x) / 2;
          const midY = (p1.y + p2.y) / 2;
          const toCenterX = cx - midX;
          const toCenterY = cy - midY;
          
          if (nx * toCenterX + ny * toCenterY < 0) {
            nx = -nx;
            ny = -ny;
          }
          
          lines.push({
            p1: { x: p1.x + nx * offset, y: p1.y + ny * offset },
            p2: { x: p2.x + nx * offset, y: p2.y + ny * offset }
          });
        }
        
        const newCorners = [];
        for (let i = 0; i < corners.length; i++) {
          const line1 = lines[i];
          const line2 = lines[(i + 1) % corners.length];
          const x1 = line1.p1.x, y1 = line1.p1.y;
          const x2 = line1.p2.x, y2 = line1.p2.y;
          const x3 = line2.p1.x, y3 = line2.p1.y;
          const x4 = line2.p2.x, y4 = line2.p2.y;
          const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
          
          if (Math.abs(denom) > 0.001) {
            const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
            newCorners.push({
              x: x1 + t * (x2 - x1),
              y: y1 + t * (y2 - y1)
            });
          } else {
            newCorners.push(corners[(i + 1) % corners.length]);
          }
        }
        
        return newCorners;
      };
      
      const placeOnGrid = (container, checkFunction, className, startIndex) => {
        let index = startIndex;
        const texts = [];
        
        for (let y = 0; y <= SVG_HEIGHT; y += GRID_STEP) {
          for (let x = 0; x <= SVG_WIDTH; x += GRID_STEP) {
            if (checkFunction(x, y)) {
              const el = createText(x, y, getHex(index++), className);
              container.appendChild(el);
              texts.push(el);
            }
          }
        }
        
        return { texts, nextIndex: index };
      };
      
      const placeOnLine = (container, p1, p2, className, startIndex, occupied = new Set()) => {
        const texts = [];
        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        const len = Math.hypot(dx, dy);
        const numSteps = Math.floor(len / GRID_STEP);
        let index = startIndex;
        
        for (let i = 0; i <= numSteps; i++) {
          const distance = i * GRID_STEP;
          if (distance <= len) {
            const t = distance / len;
            const x = p1.x + t * dx;
            const y = p1.y + t * dy;
            const key = `${Math.round(x)},${Math.round(y)}`;
            
            if (!occupied.has(key)) {
              const el = createText(x, y, getHex(index++), className);
              container.appendChild(el);
              texts.push(el);
              occupied.add(key);
            }
          }
        }
        
        return texts;
      };
      
      const v3d = [
        {x: -1, y: -1, z: -1}, {x: 1, y: -1, z: -1}, {x: 1, y: 1, z: -1}, {x: -1, y: 1, z: -1},
        {x: -1, y: -1, z: 1}, {x: 1, y: -1, z: 1}, {x: 1, y: 1, z: 1}, {x: -1, y: 1, z: 1}
      ].map(v => ({
        x: v.x * SIZE / 2,
        y: v.y * SIZE / 2,
        z: v.z * SIZE / 2
      }));
      
      const v2d = v3d.map(v => project(v.x, v.y, v.z));
      
      const front = [v2d[4], v2d[5], v2d[6], v2d[7]];
      const cx = front.reduce((sum, p) => sum + p.x, 0) / 4;
      const cy = front.reduce((sum, p) => sum + p.y, 0) / 4;
      const entrance = front.map(p => ({
        x: cx + (p.x - cx) * 0.35,
        y: cy + (p.y - cy) * 0.35
      }));
      
      const facesGroup = document.getElementById('faces');
      const faces = [
        { 
          className: 'hex-char face-top',
          check: (x, y) => inside(x, y, [v2d[3], v2d[2], v2d[6], v2d[7]])
        },
        { 
          className: 'hex-char face-right',
          check: (x, y) => inside(x, y, [v2d[1], v2d[5], v2d[6], v2d[2]])
        },
        { 
          className: 'hex-char face-front',
          check: (x, y) => {
            if (!inside(x, y, [v2d[4], v2d[5], v2d[6], v2d[7]])) return false;
            return !inside(x, y, offsetPolygon(entrance, -9));
          }
        }
      ];
      
      faces.forEach((face, idx) => {
        placeOnGrid(facesGroup, face.check, face.className, idx * 500);
      });
      
      const edgesGroup = document.getElementById('edges');
      const edges = [
        [v2d[4], v2d[5]], [v2d[5], v2d[6]], [v2d[6], v2d[7]], [v2d[7], v2d[4]],
        [v2d[1], v2d[5]], [v2d[1], v2d[2]], [v2d[2], v2d[6]],
        [v2d[3], v2d[7]], [v2d[3], v2d[2]]
      ];
      
      const edgeTexts = [];
      const edgeOccupied = new Set();
      
      edges.forEach(([p1, p2]) => {
        const texts = placeOnLine(edgesGroup, p1, p2, 'edge-char', 2000, edgeOccupied);
        edgeTexts.push(texts);
      });
      
      const entranceGroup = document.getElementById('entrance');
      const entranceTexts = [];
      const entranceOccupied = new Set();
      const entranceEdges = [
        [entrance[0], entrance[1]], [entrance[1], entrance[2]], 
        [entrance[2], entrance[3]], [entrance[3], entrance[0]]
      ];
      
      entranceEdges.forEach(([p1, p2]) => {
        const texts = placeOnLine(entranceGroup, p1, p2, 'entrance-char', 3000, entranceOccupied);
        entranceTexts.push(texts);
      });
      
      let offset = 0;
      setInterval(() => {
        offset++;
        
        edgeTexts.forEach((texts, idx) => {
          texts.forEach((el, i) => {
            el.textContent = getHex((1000 + offset + idx * 30 + i) % hexChars.length);
          });
        });
        
        entranceTexts.forEach((texts, idx) => {
          texts.forEach((el, i) => {
            el.textContent = getHex((1500 + offset + idx * 20 + i) % hexChars.length);
          });
        });
      }, 500);
    })();
  </script>
</body>
</html>
