<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>ReentrancyCat</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      background: #000;
      overflow: hidden;
      font-family: monospace;
    }
    .container {
      position: relative;
      width: 100vw;
      height: 100vh;
    }
    .bytecode-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 80%;
      overflow: hidden;
    }
    .byte {
      position: absolute;
      color: #ff3333;
      font-size: 12px;
      transition: color 0.5s;
    }
    .byte.traced {
      color: #33ff33;
    }
    .cat {
      position: absolute;
      z-index: 10;
      font-size: 14px;
    }
    .code-panel {
      position: absolute;
      bottom: 20px;
      width: 80%;
      max-width: 600px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.8);
      padding: 15px;
      border-radius: 8px;
      color: #ff3333;
      transition: transform 0.6s;
      transform-style: preserve-3d;
      cursor: pointer;
    }
    .code-panel.flipped {
      transform: translateX(-50%) rotateY(180deg);
    }
    .panel-front, .panel-back {
      backface-visibility: hidden;
      width: 100%;
    }
    .panel-back {
      position: absolute;
      top: 0;
      left: 0;
      transform: rotateY(180deg);
      background: rgba(0,0,0,0.8);
      color: #33ff33;
      padding: 15px;
      border-radius: 8px;
    }
    pre {
      margin: 0;
      white-space: pre-wrap;
    }
    .wound {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      color: white;
      font-size: 18px;
      text-align: center;
      z-index: 20;
    }
  </style>
</head>
<body>
  <div class="container" id="container">
    <div class="bytecode-container" id="bytecode-container"></div>
    <div class="wound" id="wound">lonely...lonely...</div>
    <div class="code-panel" id="code-panel">
      <div class="panel-front">
        <pre>function withdrawRewardFor(address _account) returns(bool) {
    /* ... */
    // Here the vulnerability begins
    withdrawalAccount.call.value(withdraw)(payOut);
    // State update happens too late
    totalRewardsPaid += withdraw;
    return true;
}</pre>
      </div>
      <div class="panel-back">
        <pre>function secureWithdrawRewardFor(address _account) returns(bool) {
    /* ... */
    // First record the change
    uint amount = withdraw;
    totalRewardsPaid += amount;
    // Then release the funds
    withdrawalAccount.call.value(amount)(payOut);
    return true;
}</pre>
      </div>
    </div>
  </div>
  
  <script>
    const bytecodeContainer = document.getElementById('bytecode-container');
    const codePanel = document.getElementById('code-panel');
    const THE_DAO_BYTECODE_FRAGMENT = '0x606060405236156100a75760e060020a60003504632e45c7af811461014457806343d7263f1461020c57806345323081146102a05780635c19a95c14610484578063625c17dd146104a45780636fcfff45146104aa578063758e57d0146104dd578063891bbf9f14610558578063a1d373d1146102a0578063be2290fe146105c7578063c91d951f14610152578063d71f2b411461078b578063e55cea0114610816578063ebef7432146108b9575b6101425b600160a060020a03331660009081526003602090815260408220548154600083815260202090815260408220600181015492909204851694909404915033600160a060020a031607';
    let byteElements = [];
    let catElement;
    
    function placeBytes() {
      const containerWidth = bytecodeContainer.clientWidth;
      const containerHeight = bytecodeContainer.clientHeight;
      const charWidth = 15;
      const charHeight = 15;
      
      // 列数と行数を計算
      const cols = Math.floor(containerWidth / charWidth);
      const rows = Math.floor(containerHeight / charHeight);
      const totalCells = cols * rows;
      const padding = 2;
      
      // バイトコードを配置
      for (let i = 2; i < THE_DAO_BYTECODE_FRAGMENT.length; i += 2) {
        if ((i-2)/2 < totalCells) {
          const row = Math.floor(((i-2)/2) / cols);
          const col = ((i-2)/2) % cols;
          
          const byte = document.createElement('div');
          byte.className = 'byte';
          byte.textContent = THE_DAO_BYTECODE_FRAGMENT.substr(i, 2);
          byte.style.left = (col * charWidth + padding) + 'px';
          byte.style.top = (row * charHeight + padding) + 'px';
          byte.id = 'byte-' + (i-2);
          bytecodeContainer.appendChild(byte);
          
          byteElements.push({
            element: byte,
            row: row,
            col: col
          });
        }
      }
      
      return {cols: cols, rows: rows, charWidth: charWidth, charHeight: charHeight};
    }
    
    function createCat() {
      catElement = document.createElement('div');
      catElement.className = 'cat';
      catElement.textContent = '🐾';
      catElement.style.left = '5px';
      catElement.style.top = '5px';
      container.appendChild(catElement);
      return catElement;
    }
    
    function animateCat() {
      if (!catElement) catElement = createCat();
      const gridInfo = placeBytes();
      const cols = gridInfo.cols;
      const rows = gridInfo.rows;
      const charWidth = gridInfo.charWidth;
      const charHeight = gridInfo.charHeight;
      
      // スネーク状に動くためのパスを作成（左上から右に進み、端まで行ったら次の行に進む）
      const path = [];
      for (let row = 0; row < rows; row++) {
        if (row % 2 === 0) { 
          // 偶数行: 左から右へ
          for (let col = 0; col < cols; col++) {
            path.push({x: col, y: row});
          }
        } else {
          // 奇数行: 右から左へ
          for (let col = cols - 1; col >= 0; col--) {
            path.push({x: col, y: row});
          }
        }
      }
      
      // 再入攻撃をシミュレートするためのパスの拡張
      const finalPath = [...path];
      
      // 約15ステップごとに再入攻撃を追加（前の位置に戻る）
      for (let i = 20; i < path.length; i += 15) {
        if (i + 8 < path.length) {
          // 現在位置からある程度前の位置に戻るエントリを挿入
          const reentryPoint = Math.max(0, i - 10);
          
          // 再入攻撃ポイントから始まるセグメントを挿入
          finalPath.splice(i, 0, 
            path[reentryPoint],
            path[reentryPoint + 1],
            path[reentryPoint + 2],
            path[reentryPoint + 3]
          );
        }
      }
      
      let step = 0;
      
      const moveInterval = setInterval(() => {
        if (step < finalPath.length) {
          const pos = finalPath[step];
          catElement.style.left = (pos.x * charWidth) + 'px';
          catElement.style.top = (pos.y * charHeight) + 'px';
          
          // バイトコードの色を変更
          const byteIndex = pos.y * cols + pos.x;
          if (byteIndex < byteElements.length) {
            byteElements[byteIndex].element.classList.add('traced');
          }
          
          step++;
        } else {
          clearInterval(moveInterval);
          setTimeout(() => {
            // リセットして再開
            byteElements.forEach(item => item.element.classList.remove('traced'));
            while (bytecodeContainer.firstChild) {
              bytecodeContainer.removeChild(bytecodeContainer.firstChild);
            }
            byteElements = [];
            animateCat();
          }, 3000);
        }
      }, 50);
    }
    
    // コードパネルのフリップ処理
    codePanel.addEventListener('click', () => {
      codePanel.classList.toggle('flipped');
    });
    
    // 初期化
    createCat();
    animateCat();
  </script>
</body>
</html>
